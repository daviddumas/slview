/*********************************************************************
 * Filename: genarith.c
 *
 * Description: Generate elements of arithmetic lattice associated to
 * an order in a quaternion algebra by brute force.
 * 
 * Author:        David Dumas <david@dumas.io>
 *                
 * This program is free software distributed under the MIT license.
 * See the file LICENSE for details.
 ********************************************************************/

/* This program enumerates elements of an order in a quaternion
 algebra over Q that have norm 1.  These are elements of an arithmetic
 Fuchsian group, however, the group structure is not used here at all.
 Insted, to avoid needing to find generators of the group, we just
 enumerate all elements of the order whose coefficient vectors are
 smaller than a threshold, and then filter out the ones of norm 1.

 This program is meant to be the fast inner loop of that process, so
 it expects highly processed input that is probably most convenient
 to generate from another program.

 COMMAND LINE

 There are 38 required command line arguments and 2 optional ones, in
 these groups:
 
 (Hilbert symbol) (order basis) (quad form) [MAXCOEF] [MAXNORM]

 1. Hilbert symbol: A B
 
 The Hilbert symbol is two integer arguments.  The algebra under
 consideration is then the one with presentation < i,j | i^2=a, j^2=B,
 ij=ji >.  We require A>0.

 2. Order basis: e11 e1i e1j e1k ... e41 e4i e4j e4k

 We consider the order generated by basis vectors e1,e2,e3,e4 where en
 is given by

    en1 + eni*i + enj*j + enk*(ij)

 Thus these 16 floating point arguments specify the order.

 3. Quadratic form: pp pq pr ps qq qr qs rr rs ss

 The general element of the order is x = (p*e1 + q*e2 + r*e3 + s*e4) for
 integers p,q,r,s.  The reduced norm of such an element is a quadratic
 form in p,q,r,s.  These ten integer arguments give the coefficients
 of p*p, p*q, etc., in that form.

 Note: This could be calculated from the basis of the order, but since
 this form is integral, it is convenient to specify its coefficients
 directly.  This allows the norm to be computed using only integer
 operations.

 4. MAXCOEF/MAXNORM

 The program will consider elements of the order where

   max(|p|,|q|,|r|,|s|) <= MAXCOEF

 and then will accept elements whose matrix norm (when mapped to
 SL(2,C)) is at most MAXNORM.

 By default, MAXCOEF is 200 and MAXNORM is 200.0.

 OUTPUT

 The output is a list of 4-tuples in JSON format written to STDOUT,
 with each tuple [a,b,c,d] representing a matrix [ [a,b], [c,d] ] that
 is the image of an element of the order under the matrix
 representation

 rho(i) = [ [sqrt(a),0], [0,-sqrt(a)] ]
 rho(j) = [ [0,sqrt(|b|)], [sign(b)*sqrt(|b|),0] ]

 Also, tuples [a,b,c,d] in which the first nonzero element is negative
 will be rejected.  Thus, when considering the image in PSL(2,R), the
 list of matrices output by this program injects.

*/



#define VERSION "0.1"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double OB[4][4];

// order basis matrices
double OBM[4][4];

// rep basis
double RB[4][4] = {
		   {1,0,0,1},
		   {0,0,0,0},
		   {0,0,0,0},
		   {0,0,0,0}
};

// quadratic form coefs
int coefs[10];

int QF(int *v) {
  int prods[10], res, i;

  prods[0] = v[0]*v[0];
  prods[1] = v[0]*v[1];
  prods[2] = v[0]*v[2];
  prods[3] = v[0]*v[3];
  prods[4] = v[1]*v[1];
  prods[5] = v[1]*v[2];
  prods[6] = v[1]*v[3];
  prods[7] = v[2]*v[2];
  prods[8] = v[2]*v[3];
  prods[9] = v[3]*v[3];
  res = 0;
  for (i=0;i<10;i++) {
    res += coefs[i]*prods[i];
  }
  return res;
}

double matnormsq(double *m)
{
  return m[0]*m[0] + m[1]*m[1] + m[2]*m[2] + m[3]*m[3];
}

// First nonzero entry
double FNE(double *m)
{
  for (int i=0; i<4; i++) {
    if (m[i]!=0.0) {
      return m[i];
    }
  }
  return 0.0;
}

int main(int argc, char **argv)
{
  int a,b;
  int v[4];
  int i,j,k;
  int first=1;
  double mat[4];
  int maxcoef = 200;
  double maxnorm = 200.0;
  
  a = atoi(argv[1]);
  b = atoi(argv[2]);

  for (i=0;i<4;i++) {
    for (j=0;j<4;j++) {
      OB[i][j] = atof(argv[3+4*i+j]);
      fprintf(stderr,"OB[%d][%d] = %f\n",i,j,OB[i][j]);      
    }
  }

  for (i=0;i<10;i++) {
    coefs[i] = atoi(argv[19+i]);
    fprintf(stderr,"coef[%d] = %d\n",i,coefs[i]);
  }

  if (argc > 29) {
    maxcoef = atoi(argv[29]);
    fprintf(stderr,"Using maxcoef=%d\n",maxcoef);
  }

  if (argc > 30) {
    maxnorm = atof(argv[30]);
    fprintf(stderr,"Using maxnorm=%f\n",maxnorm);
  }

  double sqrta, sqrtabsb;
  sqrta = sqrt(a);
  sqrtabsb = sqrt(abs(b));
  RB[1][0] = sqrta;
  RB[1][3] = -sqrta;
  RB[2][1] = sqrtabsb;
  RB[2][2] = (b>0?sqrtabsb:-sqrtabsb);
  RB[3][1] = sqrta*sqrtabsb;
  RB[3][2] = sqrta * (b>0?-sqrtabsb:sqrtabsb);

  for (i=0;i<4;i++) {
    for (j=0;j<4;j++) {
      OBM[i][j] = 0;
      for (k=0;k<4;k++) {
	OBM[i][j] += OB[i][k] * RB[k][j];
      }
      fprintf(stderr,"OBM[%d][%d] = %f\n",i,j,OBM[i][j]);
    }
  }
  
  printf("[\n");
  for (v[0]=-maxcoef;v[0]<=maxcoef;v[0]++) {
    for (v[1]=-maxcoef;v[1]<=maxcoef;v[1]++) {
      for (v[2]=-maxcoef;v[2]<=maxcoef;v[2]++) {
	for (v[3]=-maxcoef;v[3]<=maxcoef;v[3]++) {
	  if (QF(v)==1) {
	    for (i=0;i<4;i++) {
	      mat[i] = 0;
	      for (j=0;j<4;j++) {
		mat[i] += v[j] * OBM[j][i];
	      }
	    }
	    if ((matnormsq(mat) <= (maxnorm*maxnorm)) && (FNE(mat) >= 0.0)) {
	      if (first) {
		first = 0;
	      } else {
		printf(",\n");
	      }
	      printf("[ %.8lf, %.8lf, %.8lf, %.8lf ]",mat[0],mat[1],mat[2],mat[3]);
	    }
	  }
	}
      }
    }
  }
  printf("\n]");
}
